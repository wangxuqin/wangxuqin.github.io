---
title: base64算法简介
layout: page
categories: 算法
---

#### 定义
Base64是一种基于64个可打印字符来表示二进制数据的表示方法。

#### 历史
对于电子邮件网络的最初几十年（1971年至1990年代早期），大多数电子邮件消息都是7位US-ASCII字符集中的纯文本。二进制文件（比如图片）不能通过电子邮件进行传输，例如图片中有一个字节为0xff(即255)超过127，那么这个字节就无法通过邮件进行传输了。<br/>

为此便设计出Base64这边编码，目的就是为将二进制数据转换为7位的ASCII字符，Base64使用一组6-bit字节数组代替原来8-bit的二进制字节数组，并将该6-bit数组映射到被选定64个可打印的ASCII码之中，这样原先的二进制数组就变成一个ASCII字符串，从而顺利进行传输。<br/>

出于相同目的，还诞生了很多类似的编码，比如：uuencoding，Ascii85，SREC，BinHex，kermit等。<br/>

#### 编码算法
假设有一组二进制数组（0xff 0xfe 0xfd 0xfc 0xfb 0xfa...)<br/>

步骤1:将数组中每3个字节分为一组比如 (0xff 0xfe 0xfd), (0xfc, 0xfb, 0xfa)...<br/>

步骤2:将3个字节共24bit平均分为4个6-bit大小的数字，这里以(0xff 0xfe 0xfd)为例：<br/>
(0xff 0xfe 0xfd)即为(11111111, 11111110, 11111101)，进行6-bit分割得(111111|11, 1111|1110, 11|111101)，分割后为(111111, 111111, 111011, 111101)，用10进制表示(63, 63, 59, 61)<br/>

步骤3:将步骤2得到的(63, 63, 59, 61)进行查表替换，标准Base64算法的映射表如下所示，得到(/, /, 7, 9)。<br/>
<img src="/assets/dist/img/base64_encode_1.png" width="520px" height="90px">

步骤4:根据步骤2、3进行剩余数组的编码。

这里还存在一个问题，假如最后一组被分割数组不足3个字节，这时分为两种情况:<br/>

1)剩余2个字节:<br/>
比如(0xff 0xfe)即为(11111111, 11111110)，进行6-bit分割得到(111111|11, 1111|1110)，这时只能分割为三个部分，且第三部分不足6-bit，需要为其补上2个0，得到(111111, 111111, 111000)， 10进制表示(63, 63, 56)，根据索引值查表得到(/,  /, 4 )，因为只有三个字符，所以还需要为其补充一填充字符=，最后编码为(/, /, 4, =)。<br/>
<img src="/assets/dist/img/base64_encode_2.png" width="520px" height="90px">

2)剩余1个字节:<br/>
比如(0xff)即为(11111111,)，进行6-bit分割得到(111111|11)，这时只能分割为两个部分，且第二部分不足6-bit，需要为其补上4个0，得到(111111, 110000)， 10进制表示(63, 48)，根据索引值查表得到(/,  w)，因为只有两个字符，所以还需要为其补充两个填充字符=，最后编码为(/, w, =, =)。<br/>
<img src="/assets/dist/img/base64_encode_3.png" width="520px" height="90px">


标准Base64映射表<br/>
![base64_table](/assets/dist/img/base64_table.png)


#### Base64变种汇总表
![base64_summary_table](/assets/dist/img/base64_summary_table.png)