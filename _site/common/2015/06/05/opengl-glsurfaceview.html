<!DOCTYPE html>
<html lang="zh">
  <head>

  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>GLSurfaceView相关（转） | KimWang's blog</title>
<meta name="description" content="KimWang's blog">

<meta itemprop="name" content="">
<meta itemprop="description" content="KimWang's blog">
<meta itemprop="image" content="">

<meta property="og:url" content="http://localhost:4000/common/2015/06/05/opengl-glsurfaceview.html">
<meta property="og:type" content="website">
<meta property="og:title" content="GLSurfaceView相关（转） | KimWang's blog">
<meta property="og:site_name" content="KimWang's blog">
<meta property="og:description" content="KimWang's blog">
<meta property="og:image" content="">

<meta name="twitter:url" content="http://localhost:4000/common/2015/06/05/opengl-glsurfaceview.html">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GLSurfaceView相关（转） | KimWang's blog">
<meta name="twitter:site" content="KimWang's blog">
<meta name="twitter:description" content="KimWang's blog">

<meta property="twitter:image" content="">

<link rel="icon" type="image/x-icon" href="/assets/images/favicon.ico">

<!--
<link rel="stylesheet" href="/assets/css/app.min.css">
<link rel="alternate" type="application/rss+xml" title="KimWang's blog" href="/feed.xml">
<link rel="canonical" href="/common/2015/06/05/opengl-glsurfaceview.html">
-->

<link rel="stylesheet" href="/assets/dist/style.css">
<link rel="stylesheet" href="/assets/dist/highlight.css">
<link rel="stylesheet" href="/assets/dist/search.css">
<link rel="stylesheet" href="/assets/dist/fontsettings.css">
<link rel="stylesheet" href="/assets/dist/tool.css">




</head>

  <body>
    <div class="book without-animation with-summary font-size-2 font-family-1">
    <input type='checkbox' id='sidemenu' checked="true">
<aside>
<h3>KimWang's blog</h3>
<ul id="sideul">
    <li><a            href="http://localhost:4000/">主页</a></li>
    <li><a class="active" href="http://localhost:4000/posts.html">文章</a></li>
    <li><a  href="http://localhost:4000/tool/base64.html">工具</a></li>
    <li><a href="#">关于</a></li>
</ul> 
</aside>   

<div class="book-summary">
  <div id="book-search-input" role="search">
    <input type="text" placeholder="search">
  </div>
  <nav role="navigation">
  <ul class="summary">
    
    
    <h2>&nbsp;&nbsp;android</h2>
    
      <li ><a href="/android/2015/04/15/basic-width-android.html">&nbsp;&nbsp;&nbsp;&nbsp;1.android基础知识</a></li>
    
      <li ><a href="/android/2015/04/13/problem-width-android-orientation.html">&nbsp;&nbsp;&nbsp;&nbsp;2.android横竖屏切换时的一些问题</a></li>
    
  
    <li class="divider"></li>
    <h2>&nbsp;&nbsp;Common</h2>
    
      <li ><a href="/common/2015/04/30/linux_system_signal.html">&nbsp;&nbsp;&nbsp;&nbsp;1.Linux信号signal处理机制（转）</a></li>
    
      <li ><a href="/common/2015/04/29/timelinefx.html">&nbsp;&nbsp;&nbsp;&nbsp;2.Timelinefx粒子编辑器</a></li>
    
      <li ><a href="/common/2015/04/20/common-cmd.html">&nbsp;&nbsp;&nbsp;&nbsp;3.C/C++常用命令</a></li>
    
      <li ><a href="/common/2015/04/20/dll-and-so-compare.html">&nbsp;&nbsp;&nbsp;&nbsp;4.Window动态库与Linux共享对象比较（转）</a></li>
    
  
    <li class="divider"></li>
    <h2>&nbsp;&nbsp;Android</h2>
    
      <li ><a href="/android/2015/05/04/question-width-android.html">&nbsp;&nbsp;&nbsp;&nbsp;1.android开发问题集</a></li>
    
  
    <li class="divider"></li>
    <h2>&nbsp;&nbsp;AS3</h2>
    
      <li ><a href="/as3/2015/05/08/filereference.html">&nbsp;&nbsp;&nbsp;&nbsp;1.使用 FileReference 类（转）</a></li>
    
  
    <li class="divider"></li>
    <h2>&nbsp;&nbsp;common</h2>
    
      <li class="active"><a href="/common/2015/06/05/opengl-glsurfaceview.html">&nbsp;&nbsp;&nbsp;&nbsp;1.GLSurfaceView相关（转）</a></li>
    
      <li ><a href="/common/2015/06/03/color-calculator.html">&nbsp;&nbsp;&nbsp;&nbsp;2.常用色彩模型转换算法</a></li>
    
      <li ><a href="/common/2015/05/26/fragment.html">&nbsp;&nbsp;&nbsp;&nbsp;3.常用代码片段</a></li>
    
  
  </ul>
</nav>
</div>

<div id='wrap'>
    <label id='sideMenuControl' for='sidemenu'>≡</label>
</div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <div style="display: none">TODO: share icons</div>
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i>
            <a>GLSurfaceView相关（转）</a>
          </h1>
        </div>
        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">
            <div id="book-search-results">
              <div class="search-noresults">
                <section class="normal markdown-section">
                  <p>###1.GLSurfaceView简介
GLSurfaceView是一个视图，继承至SurfaceView，它内嵌的surface专门负责OpenGL渲染。 GLSurfaceView提供了下列特性:<br />
<i>
  1.软件一个surface，这个surface就是一块特殊的内存，能直接排版到android的视图view上。<br />
  2.管理一个EGL display，它能让opengl把内容渲染到上述的surface上。<br />
  3.用户自定义渲染器(render)。<br />
  4.让渲染器在独立的线程里运作，和UI线程分离。<br />
  5.支持按需渲染(on-demand)和连续渲染(continuous)。<br />
  6.一些可选工具，如调试。<br />
</i></p>

<p><strong>使用GLSurfaceView</strong><br />
通常会继承GLSurfaceView，并重载一些和用户输入事件有关的方法。如果你不需要重载事件方法，GLSurface也可以直接使用，你可以使用set方法来为该类提供自定义的行为。例如，GLSurfaceView的渲染被委托给渲染器在独立的渲染线程里进行，这一点和普通视图不一样，setRenderer(Renderer)设置渲染器。</p>

<p><strong>初始化GLSurfaceView</strong><br />
初始化过程起始仅需要你使用<b><font color="#4472C4">setRenderer(Renderer)</font></b>设置指一个渲染器(render)。当然，你也可以修改GLSurfaceView一些默认配置。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="n">setDebugFlags</span><span class="o">(</span><span class="kt">int</span><span class="o">);</span>  
<span class="o">(</span><span class="mi">2</span><span class="o">)</span><span class="n">setEGLConfigChooser</span><span class="o">(</span><span class="kt">boolean</span><span class="o">);</span>   
<span class="o">(</span><span class="mi">3</span><span class="o">)</span><span class="n">setEGLConfigChooser</span><span class="o">(</span><span class="n">EGLConfigChooser</span><span class="o">);</span>  
<span class="o">(</span><span class="mi">4</span><span class="o">)</span><span class="n">setEGLConfigChooser</span><span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">);</span>  
<span class="o">(</span><span class="mi">5</span><span class="o">)</span><span class="n">setGLWrapper</span><span class="o">(</span><span class="n">GLWrapper</span><span class="o">);</span>  
</code></pre></div></div>

<p><strong>定制android.view.Surface</strong><br />
GLSurfaceView默认会创建像素格式为<b><font color="#4472C4">PixelFormat.RGB_565</font></b>的surface。如果需要透明效果，调用getHolder.setFormat(PixelFormat.TRANSLUCENT)。透明的surface像素格式都是32位，每个色彩单元都是8位深度，像素格式是设备相关的，这意味着它可能是ARGB、RGBA或其它。</p>

<p><strong>选择EGL配置</strong><br />
Andoid设备往往支持多种EGL配置，可以使用不同数目的通道(channel)，也可以指定每个通道具有不同数目的位(bits)深度。  因此，在渲染器工作之前就应该指定EGL的配置。  GLSurfaceView默认EGL配置的像素格式为RGB_656，16位的深度缓存(depth buffer)，  默认不开启遮罩缓存(stencil buffer)。如果你要选择不同的EGL配置，使用setEGLConfigChooser方法中的一种。</p>

<p><strong>调试行为</strong><br />
你可以调用调试方法<b><font color="#4472C4">setDebugFlags(int)</font></b>或<b><font color="#4472C4">setGLWrapper(GLSurfaceView.GLWrapper)</font></b>来定义GLSurfaceView一些行为。  在setRenderer方法之前或之后都可以调用调试方法，不过只好在之前调用，这样它们能够立即生效。</p>

<p><strong>渲染模式</strong><br />
渲染器设定之后，你可以使用<b><font color="#4472C4">setRenderMode(int)</font></b>指定渲染模式是按需<b><font color="#4472C4">(on demand)</font></b>还是连续<b><font color="#4472C4">(continuous)</font></b>。默认是连续渲染。</p>

<p><strong>Activitiy生命周期</strong><br />
Activity窗口暂停<b><font color="#4472C4">pause</font></b>或恢复<b><font color="#4472C4">resume</font></b>时，GLSurfaceView都会收到通知，此时它的<b><font color="#4472C4">onPause</font></b>方法和<b><font color="#4472C4">onResume</font></b>方法应该被调用。这样做是为了让GLSurfaceView暂停或恢复它的渲染线程，以便它及时释放或重建OpenGL的资源。</p>

<p><strong>事件处理</strong><br />
为了处理事件，一般都是继承GLSurfaceView类并重载它的事件方法。但是由于GLSurfaceView是多线程操作，所以需要一些特殊的处理。由于渲染器在独立的渲染线程里，你应该使用Java的跨线程机制跟渲染器通讯。<b><font color="#4472C4">queueEvent(Runnable)</font></b>方法就是一种相对简单的操作，例如下面的例子。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyGLSurfaceView</span> <span class="kd">extends</span> <span class="n">GLSurfaceView</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="n">MyRenderer</span> <span class="n">mMyRenderer</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">(){</span>
		<span class="n">mMyRenderer</span> <span class="o">=</span> <span class="o">..;</span>
		<span class="n">setRenderer</span><span class="o">(</span><span class="n">mMyRenderer</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onKeyDown</span><span class="o">(</span><span class="kt">int</span> <span class="n">keyCode</span><span class="o">,</span> <span class="n">KeyEvent</span> <span class="n">event</span><span class="o">){</span>
		<span class="k">if</span><span class="o">(</span><span class="n">keyCode</span> <span class="o">==</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">KEYCODE_DPAD_CENTER</span><span class="o">){</span>
			<span class="n">queueEvent</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">(){</span>
				<span class="c1">//这个方法会在渲染线程里被调用</span>
				<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
					<span class="n">mMyRenderer</span><span class="o">.</span><span class="na">handleDpadCenter</span><span class="o">();</span>
				<span class="o">}</span>
			<span class="o">});</span>
			<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">onKeyDown</span><span class="o">(</span><span class="n">keyCode</span><span class="o">,</span> <span class="n">event</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>(注：如果在UI线程调用渲染器的方法，很容易收到”call to OpenGL ES API with no context”的警告，典型的误区就是在键盘或鼠标事件方法里直接调用opengl es的API,因为UI事件和渲染绘制在不同线程里。更甚者，这种情况下调用glDeleteBuffers这种释放资源的方法，可能引起程序的奔溃，因为UI线程想释放它，渲染线程却要使用它)。</p>

<p>###2.非交互式Demo</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** 
 * 本示例演示OpenGL ES开发3D应用 
 * 该Activity直接使用了GLSurfaceView 
 * 这是因为GLSurfaceView可以直接使用，除非需要接受用户输入，和用户交互，才需要重写一些GLSurfaceView的方法 
 * 如果开发一个非交互式的OpenGL应用，可以直接使用GLSurfaceView。参照本示例 
 * @author Administrator 
 * 
 */</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NonInteractiveDemo</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
	
	<span class="kd">private</span> <span class="n">GLSurfaceView</span> <span class="n">glView</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">glView</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GLSurfaceView</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">glView</span><span class="o">.</span><span class="na">setRenderer</span><span class="o">(</span><span class="k">new</span> <span class="n">DemoRender</span><span class="o">());</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">glView</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">DemoRender</span> <span class="kd">implements</span> <span class="n">Renderer</span> <span class="o">{</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDrawFrame</span><span class="o">(</span><span class="n">GL10</span> <span class="n">gl</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//每帧都需要调用该方法进行绘制，绘制时通常先调用glClear来清空framebuffer</span>
		<span class="c1">//然后调用OpenGL ES其他接口进行绘制</span>
		<span class="n">gl</span><span class="o">.</span><span class="na">glClear</span><span class="o">(</span><span class="n">GL10</span><span class="o">.</span><span class="na">GL_COLOR_BUFFER_BIT</span><span class="o">|</span><span class="n">GL10</span><span class="o">.</span><span class="na">GL_DEPTH_BUFFER_BIT</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSurfaceChanged</span><span class="o">(</span><span class="n">GL10</span> <span class="n">gl</span><span class="o">,</span> <span class="kt">int</span> <span class="n">width</span><span class="o">,</span> <span class="kt">int</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//当surface的尺寸发生改时，该方法被调用，往往在这里设置ViewPort，或者Camera等</span>
		<span class="n">gl</span><span class="o">.</span><span class="na">glViewport</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSurfaceCreated</span><span class="o">(</span><span class="n">GL10</span> <span class="n">gl</span><span class="o">,</span> <span class="n">EGLConfig</span> <span class="n">config</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//该方法在渲染开始前调用，OpenGL ES的绘制上下问被重建时也会调用</span>
		<span class="c1">//当Activity暂停时，绘制上下问会丢失，当Activity恢复时，绘制上下文会重建</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>###3.交互式</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">example</span><span class="o">.</span><span class="na">interactivedemo</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.microedition.khronos.egl.EGLConfig</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.microedition.khronos.opengles.GL10</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">android.app.Activity</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.content.Context</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.opengl.GLSurfaceView</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.opengl.GLSurfaceView.Renderer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.os.Bundle</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.view.MotionEvent</span><span class="o">;</span>
<span class="cm">/**
 * 本示例演示OpenGL ES开发3D应用
 * 该Activity使用了自定义的GLSurfaceView的子类
 * 这样，我们可以开发出和用户交互的应用，比如游戏等。
 * 需要注意的是：由于渲染对象是运行在一个独立的渲染线程中，所以
 * 需要采用跨线程的机制来进行事件的处理。但是Android提供了一个简便的方法
 * 我们只需要在事件处理中使用queueEvent(Runnable)就可以了.
 * 
 * 对于大多数3D应用，如游戏、模拟等都是持续性渲染，但对于反应式应用来说，只有等用户进行了某个操作后再开始渲染。
 * GLSurfaceView支持这两种模式。通过调用方法setRenderMode()方法设置。
 * 调用requestRender()继续渲染。
 * 
 * 
 * @author Administrator
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InteractiveDemo</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
	
	<span class="kd">private</span> <span class="n">GLSurfaceView</span> <span class="n">mGLView</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">){</span>
		<span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
		<span class="n">mGLView</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DemoGLSurfaceView</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="c1">//这里使用的是自定义的GLSurfaceView的子类</span>
		<span class="n">setContentView</span><span class="o">(</span><span class="n">mGLView</span><span class="o">);</span>
	<span class="o">}</span>
	
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onPause</span><span class="o">(){</span>
		<span class="kd">super</span><span class="o">.</span><span class="na">onPause</span><span class="o">();</span>
		<span class="n">mGLView</span><span class="o">.</span><span class="na">onPause</span><span class="o">();</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onResume</span><span class="o">(){</span>
		<span class="kd">super</span><span class="o">.</span><span class="na">onResume</span><span class="o">();</span>
		<span class="n">mGLView</span><span class="o">.</span><span class="na">onResume</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">DemoGLSurfaceView</span> <span class="kd">extends</span> <span class="n">GLSurfaceView</span><span class="o">{</span>
	<span class="n">DemoRenderer</span> <span class="n">mRenderer</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">DemoGLSurfaceView</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
		<span class="kd">super</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
		<span class="c1">//为了可以激活log和错误检查，帮助调试3D应用，需要调用setDebugFlags()。</span>
		<span class="k">this</span><span class="o">.</span><span class="na">setDebugFlags</span><span class="o">(</span><span class="n">DEBUG_CHECK_GL_ERROR</span><span class="o">|</span><span class="n">DEBUG_LOG_GL_CALLS</span><span class="o">);</span>
		<span class="n">mRenderer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DemoRenderer</span><span class="o">();</span>
		<span class="k">this</span><span class="o">.</span><span class="na">setRenderer</span><span class="o">(</span><span class="n">mRenderer</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onTouchEvent</span><span class="o">(</span><span class="kd">final</span> <span class="n">MotionEvent</span> <span class="n">event</span><span class="o">){</span>
		<span class="c1">//由于DemoRenderer2对象运行在另一个线程中，这里采用跨线程的机制进行处理。使用queueEvent方法</span>
		<span class="c1">//当然也可以使用其他像Synchronized来进行UI线程和渲染线程进行通信。</span>
		<span class="k">this</span><span class="o">.</span><span class="na">queueEvent</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
			
			<span class="nd">@Override</span>
			<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
				<span class="n">mRenderer</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getX</span><span class="o">()/</span><span class="n">getWidth</span><span class="o">(),</span> <span class="n">event</span><span class="o">.</span><span class="na">getY</span><span class="o">()/</span><span class="n">getHeight</span><span class="o">(),</span> <span class="mf">1.0f</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">});</span>
		
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
	<span class="o">}</span>
	
<span class="o">}</span>
<span class="cm">/**
 * 这个应用在每一帧中清空屏幕，当tap屏幕时，改变屏幕的颜色。
 * @author Administrator
 *
 */</span>
<span class="kd">class</span> <span class="nc">DemoRenderer</span> <span class="kd">implements</span> <span class="n">Renderer</span><span class="o">{</span>
	
	<span class="kd">private</span> <span class="kt">float</span> <span class="n">mRed</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">float</span> <span class="n">mGreen</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">float</span> <span class="n">mBlue</span><span class="o">;</span>
	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDrawFrame</span><span class="o">(</span><span class="n">GL10</span> <span class="n">gl</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">gl</span><span class="o">.</span><span class="na">glClearColor</span><span class="o">(</span><span class="n">mRed</span><span class="o">,</span> <span class="n">mGreen</span><span class="o">,</span> <span class="n">mBlue</span><span class="o">,</span> <span class="mf">1.0f</span><span class="o">);</span>
		<span class="n">gl</span><span class="o">.</span><span class="na">glClear</span><span class="o">(</span><span class="n">GL10</span><span class="o">.</span><span class="na">GL_COLOR_BUFFER_BIT</span><span class="o">|</span><span class="n">GL10</span><span class="o">.</span><span class="na">GL_DEPTH_BUFFER_BIT</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSurfaceChanged</span><span class="o">(</span><span class="n">GL10</span> <span class="n">gl</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">,</span> <span class="kt">int</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">gl</span><span class="o">.</span><span class="na">glViewport</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">h</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSurfaceCreated</span><span class="o">(</span><span class="n">GL10</span> <span class="n">gl</span><span class="o">,</span> <span class="n">EGLConfig</span> <span class="n">config</span><span class="o">)</span> <span class="o">{</span>
		
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setColor</span><span class="o">(</span><span class="kt">float</span> <span class="n">r</span><span class="o">,</span> <span class="kt">float</span> <span class="n">g</span><span class="o">,</span> <span class="kt">float</span> <span class="n">b</span><span class="o">){</span>
		<span class="k">this</span><span class="o">.</span><span class="na">mRed</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">mGreen</span> <span class="o">=</span> <span class="n">g</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">mBlue</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

                </section>

                <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a>
              </div>
            <div class="search-results">
              <div class="has-results">
                <h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
                <ul class="search-results-list"></ul>
              </div>
            <div class="no-results">
              <h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
            </div>
            </div>
            </div>
          </div>
        </div>
      </div>


      <!--<a href="rpi3.html" class="navigation navigation-next navigation-unique" aria-label="Next page: 2016 Raspberry Pi Model 3 B" style="margin-right: 0px;">
          <i class="fa fa-angle-right"></i>
      </a>
    </div> -->
</div>

    
  </body>
</html>
