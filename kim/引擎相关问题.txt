iPoker项目开展过程引擎的不足：
以下分为
(1)win32模拟器
(2)动画
(3)MVC架构
(4)UI编辑器
(5)动画编辑器
(6)BebeLua
(7)UI组件

(1)win32 模拟器存在问题:
1.编译share program速度较慢：
在项目开展过程中，发现只要share program较多时，第一次开启win32模拟器的速度非常缓慢：持续3-5秒时间。

2.win32 模拟器不能下载图片及配置文件(.lua, .xml)：
以及其他文件如一些cdn上面的配置文件，这个对项目开发效率影响非常大。
比如开发完涉及但图片，或者加载配置文件的功能，都需要在安卓上跑才能看到效果。

(2)动画
1.动画采用addProp方式，需要管理对应的sequence。
但是很难妥善管理好sequence，比如添加动画需要一个找到该节点没用用过sequence。

2.动画非常容易出现泄漏情况。这种情况对新手或者老手都很避免。
同时在项目到了结束的时候要扫光动画的泄漏的BUG，非常耗时。
其实动画容易泄漏原因比较根本在于四类对象的概念，
核心在于动画与drawing分离，
分离就意味动画与drawing需要分开管理，drawing被销毁，动画还依然存活。

3.动画的方式会产生副作用：
添加动画的时候只能加上对应的AnimProp，一旦AnimProp播放结束后，不能移除AnimProp，因为移除drawing就会打回原型。
这种对于那些“叠加”类型的动画：如平移，旋转，影响还算可以接纳，但是对于“乘积”类型的动画：如color，透明度，缩放
这一类动画，使用起来就非常难：比如需要做一个透明度变化的动画，先把透明度从1变成0.5，再从0.5变成0.1，再从0.1变化回1，
一般会这样做：
1: 1 , 0.5
2: 1 , 0.2 --在0.5作用下，需要加上从1到0.2的变化值。
3: 1 , 5   --在0.2作用下，需要加上从1到5的变化值。

但是采用上面上面的方法还是有问题：问题在于第三步5为非法值，在底层的函数会将5截成1。
所以正确做法：
1: 1, 0.5
2: 1, 0.2
3: 移除所有有关透明度的AnimProp
4: 0.1, 0.5

所以这种采用addProp这种方式，做动画会较为困难。

4.动画缺乏每帧回调的官方接口。
每帧回调是解决上面问题3的关键，而且还是下面要讲动画编辑器的问题解决的关键，但是目前缺乏官方接口，导致项目很多地方的每帧回调无法统一管理。

5.动画泄漏调试起来较为困难：
动画一旦泄漏，在项目后期非常难找出并解决。目前可以通过setDebugName用于标识动画，但是这种方式只有在动画回调时，回调函数错误才会起效。
所以一种有效的调试途径解决这个问题。

(3)MVC架构
1.架构是一个缺乏M的架构，缺少数据管理的部分。这样会造成Controller与View结合较为松散。
2.架构比较冗余，冗余带来的结果不言而喻。
3.事件与模块中对应的处理函数的定义处于模块末尾位置：
	这种结构会带来一个问题：就是很难找到这种模块的核心功能。
4.事件与模块进行绑定，这种结构会出现一种情况，
	比如:有三个ModelA,ModelB,ModelC，ModelA与ModelB都有一个相同事件EventA,现在模块C想侦听事件EventA，
	那么就必须同时侦听模块A和模块B的事件。这种结构造成，如果有要新增或者移除一个模块（都有事件EventA）,都需要修改模块C的侦听。
5.布局文件与模块组件对应不明确，或者说比较绕。
	布局文件与模块组件定义是通过一张表对应的，这张表核心内容就是:flag = {"name1", "name2", "name3"};使用数组部分去获取布局文件生成组件，使用
	flag部分去做其他的关联，比如对于按钮来说，会去关联"setOnClick"函数。这种方式比较不直观。

6.组件事件关联
	这个本来是为了使用本框架的开发者，但是使用这个首先不能解决所有问题，比如需要关联组件的其他函数时就需要自己另外写，这种造成不统一。

7.contoller与view的生命周期一致，比如一般如果将登出游戏的逻辑写到登录模块中，一般在其他场景调用登出游戏时，登录模块是无法响应的，因为此时contoller与view已经销毁。所以采用这种结构很难把相关的逻辑都写在对应的模块中。

8.contoller与view函数对应只能通过事件，以及updateView这种方式进行相互调用或者通知，这种感觉使用起来不便，而且耦合性非常强烈。

(4)UI编辑器
1.UI编辑器与VS嵌合在一起，使用起来非常不适应，造成这种情况的原因：
	(1)编辑视野，将VS中无法将编辑器各个子窗口进行尺寸、位置调整。这样造成显示区域没有以前独立版那么空旷。
	(2)无法对照UI编辑器写代码。一旦把UI编辑编辑器以最大化的形式（不使用最大化的形式又得不到足够的视野），就无法像以前那样可以对照着UI编辑器编写对应代码。
	(3)功能区的调整，功能按钮布局跟前区别太大，一时很难适应。

2.UI编辑器缺乏模版概念；
	虽然有一个自定义组件，但是使用起来比较不便，如果有一个自定义模版，在每次新建的时候，就采用定义好的模版，效率会高很多。

3.UI编辑器缺乏精细操作：
	(1)锁		: 在UI编辑器上面很容易出现的误操作就是拖错组件，导致需要回退，如果有锁，就能锁定以及编辑的好的组件。
	(2)层级调整	：层级调整，层级调整依赖拖动组件树，但是在组件树上拖动非常不方便，单独提供菜单项反而可以做到一次到位的效果。
	(3)对齐方式 ：对齐方式对于编辑是非常重要的，可以极大提高编辑效率。

(5)动画编辑器
动画编辑器目前还处于一个很初级化的阶段，存在不少的问题，虽然@曾祥清的swf转换器能替代动画编辑器的大部分功能，但是动画编辑器还是有存在的意义。动画编辑器可为程序员提供一个较好的工具协助其构建较为复杂动画。下面是我这边设想：
重构动画编辑器：
1.动画编辑器以UI编辑器为基础。
2.动画编辑器采用每帧回调作为动画实现。
3.动画编辑器必须有时间轴。
最终的阶段就是将UI编辑器与动画编辑器合并，并且以独立软件形式存在。

(6)BebalLua
1.当代码级数为8-10万行开始，BebaLua开始变得卡顿。
2.希望BebalLua能提供检查功能，检查是否同一个函数是否存在重复定义的。
3.批量转化文本格式，检查文本是否为utf-8格式，将其转换为utf-8格式。

7.UI组件
1.新UI组件，使用过于复杂，虽然这种是由于异步造成的，但是需要额外处理那么复杂的东西会极大的提高使用门槛，阻碍组件的推广。
2.新UI组件，内部采用非常规的代码形式，项目组的人员无法继承并扩展功能。这样会造成要么就向引擎组求助解决，并要求快速解决，要么就索性不使用这个组件，重新编写一个类似组件。